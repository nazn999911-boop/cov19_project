# README — Модель R(t) и прогноз по COVID-19 (Россия, Италия, Германия, Франция)

## 1) Постановка задачи (что именно требовалось)

В рамках задания нужно:

1. **Прокомментировать код** — объяснить, зачем используется каждая ключевая строка/блок.
2. **Обучить модель** на данных о новых выявленных случаях COVID-19 за период **01.01.2020—01.12.2020** по странам: **Россия, Италия, Германия, Франция**.  
   При этом **игнорировать все дни до того, как дневная заболеваемость превысит 100 случаев**.
3. **Оценить динамику эффективного репродуктивного числа R(t)** на этом периоде.
4. **Сделать прогноз** числа зарегистрированных случаев **и** R(t) на даты **02.12.2020—14.12.2020** и **сравнить с реальностью**.

---

## 2) Как мы это решаем — коротко, по шагам

- **Данные.** Загружаем открытые CSV из OWID: помер-по-дням (JHU) и тестирование (OWID testing).  
- **Фильтр.** Для каждой страны находим **первый день с `new_cases > 100`**, отсекаем всё ранее. Учебное окно — до **2020-12-01** включительно.
- **Модель инфекций.** Не **SIR**, а **renewal-модель** (уравнение обновления): инфекции на день t зависят от прошлых инфекций, свернутых с **generation interval** (распределение интервалов между заражениями), и масштабируются **R(t)**.
- **Задержки наблюдения.** Инфекции не видны сразу. Мы моделируем **инкубацию + задержку подтверждения** и сворачиваем инфекции с распределением задержки, получая ожидаемые «подтвержденные» случаи.
- **Тестовая активность.** Вводим **exposure** — прокси «интенсивности тестирования», чтобы не переоценивать случаи, когда тестов мало.
- **Наблюдение.** Реальные «положительные» — счётчики с **пере-дисперсией**, поэтому используем **Negative Binomial** (Гамма-Пуассон).
- **R(t).** Ставим **априорный гауссовский random walk по `log R(t)`**, изменяющийся «кусками» раз в 3 дня — гладкая траектория с умеренными изменениями.
- **Вывод (MC).** Байесовский вывод через **NUTS** (NumPyro/JAX при наличии → быстрее; иначе стандартный PyMC).  
- **Прогноз.** Делаем **posterior predictive** на будущее окно (02.12—14.12.2020), сравниваем c фактами.

---

## 3) Математика модели

### 3.1 Renewal-динамика инфекций

Пусть \( y_t \) — число **новых инфекций** (истинных, до наблюдательных задержек) в день \( t \).  
Пусть \( g_k \) — дискретизированное **generation interval** (вероятность, что вторичная инфекция произойдёт через \( k \) дней). Тогда **уравнение обновления**:

\[
y_t \;=\; R_t \sum_{k=1}^{K} y_{t-k}\, g_k \quad (t \ge 1), \qquad y_0 \sim \text{Exponential}(\lambda)
\]

- \(R_t\) — **эффективное репродуктивное число** на день \( t \).
- \(g_k\) мы берём из **логнормального** приближения (эмпирика по COVID-19), нормируем так, чтобы \(\sum_k g_k=1\).

### 3.2 Приор для \(R_t\)

Работаем с \(\log R_t\) и задаём **гауссовский случайный блуждающий процесс**:

\[
\log R_{t}^{(\text{coarse})} \sim \text{GRW}(\sigma), \quad
\log R_t = \text{repeat}\!\left(\log R_{t}^{(\text{coarse})},\; \text{step}=3\right)
\]

То есть \(R_t\) меняется **раз в 3 дня**, что стабилизирует оценивание и даёт гладкую траекторию.  
Далее \( R_t = \exp(\log R_t) \).

### 3.3 Задержки (инкубация + от симптомов до подтверждения)

Пусть \( d_\tau \) — распределение **задержки от инфекции до регистрации** (инкубация + задержка подтверждения).  
Мы используем: инкубация ≈ **5 дней** (сдвиг), плюс логнормальная задержка от симптомов до подтверждения (~mean 4.7, std 2.9).  
Тогда **ожидаемые регистрируемые (до тестового масштаба) случаи**:

\[
c_t^{(\text{pre-test})} \;=\; \sum_{\tau=0}^{D} y_{t-\tau}\, d_\tau
\]

### 3.4 Масштаб по тестам («exposure»)

Чтобы отражать, что при малом количестве тестов часть случаев останется незамеченной, видимую интенсивность склеиваем с объёмом тестирования.  
Пусть \( \text{tests}_t \) — число тестов (после дополнения «буфера»). Вводим **нижний порог** \(\text{baseline} = 0.1 \times \max(\text{tests})\) и определяем:

\[
\text{exposure}_t = \max(\text{tests}_t,\ \text{baseline})
\]
\[
\mu_t = \text{exposure}_t \cdot c_t^{(\text{pre-test})}
\]

Здесь \( \mu_t \) — **ожидаемое** число подтверждённых случаев на день \( t \).

### 3.5 Наблюдательная модель (Negative Binomial)

Реальные дневные случаи шумные и пере-дисперсные, поэтому используем **Negative Binomial**:

\[
C_t \sim \text{NegBinom}(\mu_t,\ \alpha),
\quad \alpha \sim \text{Gamma}(\mu=4,\ \sigma=2)
\]

Мы подбираем \( C_t \) **только** на днях, где есть тесты (\(\text{total} > 0\)) и в нашем историческом окне.  

### 3.6 Постериорный вывод и прогноз

- Выводим совместное апостериорное распределение параметров: \( \{ R_t, y_t, \alpha, \text{seed} \} \).
- Для прогнозов на будущие дни продолжаем динамику \(y_t\) через renewal-уравнение, затем преобразуем к ожидаемым дням \( \mu_t \) и генерируем «наблюдённые» из NB.  
- Для **R(t)** берём постериорные выборки \(\log R_t\), сводим к **медиане** и **80% HDI**.

---

## 4) Монте-Карло/вычислительная часть (NUTS) — пошаговый план

1. **Сбор данных** (OWID CSV по кейсам и тестам), парсим в `pandas`.
2. **Фильтрация окна:**  
   - находим **первую дату**, где `new_cases > 100`;  
   - историческое окно: от этой даты до **2020-12-01**.
3. **Формирование индекса:**  
   - добавляем **`buffer_days` слева** (для «невидимого» разгона инфекций до первого ненулевого дня),  
   - и **`future_days` справа** — для прогноза.
4. **Построение PyMC-модели:**  
   - **prior** на `log_r_coarse` как GRW; «растягиваем» его до дневной сетки;  
   - **renewal-скан** (`pytensor.scan`) для вычисления \(y_t\);  
   - **свёртка** с задержками (через `conv2d` для скорости) → \(c_t^{(\text{pre-test})}\);  
   - **масштаб тестов** → \(\mu_t\);  
   - **Negative Binomial** по наблюдаемым дням.
5. **NUTS-образец (MCMC):**  
   - Если доступен JAX/NumPyro — используем `sample_numpyro_nuts` (быстрее); иначе `pm.sample` (PyMC).  
   - Получаем `InferenceData` с панелями по `chain × draw`.
6. **Posterior Predictive:**  
   - генерируем предиктивы для `positive`/`nonzero_positive` на полной сетке дат (включая будущее).  
7. **Агрегация результатов:**  
   - по \(R(t)\): медиана и 80% HDI;  
   - по кейсам: средние/квантили предсказаний;  
   - выгружаем CSV и строим графики;  
   - сравниваем прогноз (02.12—14.12) с фактом.

---
